<!DOCTYPE html>
<html>
<head>
   <title>Pathfinding Algorithm Visualizer</title>
	<style>
div {
   border: dotted 1pt black;
   padding: 0px;
   margin: 90px 20px;
}

</style>

<meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>

</head>
<body style="background-image:url('Grid.jpg');">
<h1>
Algorithms: A*,Depth First,Bredth First
</h1>
<div class="container">
    <h2>Pathfinding Algorithms</h2>            
    <table class="table table-hover">
      <thead>
        <tr>
          <th>Video</th>
          <th>Information</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><iframe width="420" height="315"
            src="https://www.youtube.com/watch?v=ySN5Wnu88nE&ab_channel=Computerphile">
            </iframe></td>
          <td>The shortest path in any situation after checking all values and finding the smallest amount per vertex.
            Similar to Dijkstra’s Shortest Path Algorithm in that the goal is to find the shortest distance one can travel from going to the starting node to the target node and Greedy Best-First-Search’s idea to only follow the shortest paths.
            f(n)=g(n)+h(n)
            Where g(n) is the sum of all the nodes that have been touch since the start.
            h(n) is the heuristic value that is the estimated value of the entire travel.</td>
        </tr>
        <tr>
          <td><iframe width="420" height="315"
            src="https://https://www.youtube.com/watch?v=7fujbpJ0LB4&ab_channel=WilliamFiset">
            </iframe></td>
          <td>Known as depth first because it searches for the deepest node first. 
            Uses a stack to remember to get to the next vertex.
            Goes through every vertex and must backtrack 
            1. Go to adjacent unvisited vertex, mark it as visited and push it into the stack.
            2. If none are found, pop up a vertex.
            3. Repeat 1 and 2 until the stack’s empty.</td>
        </tr>
        <tr>
          <td><iframe width="420" height="315"
            src="https://www.youtube.com/watch?v=oDqjPvD54Ss&ab_channel=WilliamFiset">
            </iframe></td>
          <td>Queue used to remember to search the next vertex and when a dead end occurs a new search is done again.
            1. Go to adjacent unvisited vertex, mark it as visited and insert into the queue.
            2. If none are found, remove the first vertex.
            3. Repeat 1 and 2 until the queue is empty.</td>
        </tr>
      </tbody>
    </table>
  </div>
</body>
<footer style="background-color:black">
    <p style="color:white">By Curtiss Stacey, Gerardo Rodriguez, and Kristine Veneles  
    </p>
  </footer>
</html>
